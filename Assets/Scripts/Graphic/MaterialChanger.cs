using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MaterialChanger : MonoBehaviour
{
    [SerializeField] Renderer render;
    [SerializeField] Material normalMaterial;
    [SerializeField] Material highlightMaterial;
    [SerializeField] Material lerpMat;

    private void Start()
    {
        // 그래픽 최적화
        // 일단 움직이지 않는 물체 static 처리
        //render.material.color = Color.red;
        // 이렇게 수식을 짰을때의 문제.
        // 하나의 마테리얼의 변경사항이 있었을 때 컴퓨터는 그 복사본을 만든다. 근데 이게 최적화에선 독이될 경우가 있다.
        // 그래서 같은 마테리얼을 쓰는 박스 3개중 박스 1의 색을 빨간색으로 바꿨다고 가정해보자. 
        // 이 경우 마테티얼을 복사해 빨간색으로 바꿔놓고 다시 흰색으로 바꾸면 원을 쓰는데, 빨간색으로 바뀐 마테리얼이 남는다.
        // 이러고 박스 2의 색을 빨간색으로 바꾸면 또 빨간색 마테리얼이 생긴다. 이게 발적화의 원인이 된다. 
        // 그래서 이거 절대로 하면 안되는 코드다.
        // 이 특징을 이해했다면, 하이라이트 마테리얼을 만들어 마테리얼 자체를 변경해주는 방식으로 하자
        render.material = highlightMaterial;
        // 이런식으로
        // 텍스쳐 프리 로딩이라고 해서 쓸 마테리얼을 미리 불러오는 기술도 있다. 
        // lerp가 필요하면
        //render.material = lerpMat.sh...이부분은 다시보기 보고 완성        
    }
    // 어디서 부하가 심하게 걸리는지 보는 곳은 
    // 윈도우 / 애널라이시스 / 프로파일러
    //
    // 빛 그림자 최적화의 경우
    // 빛, 그림자, 물체가 움직이지 않는다면, 굳이 빛처리로 지속적인 부하가 발생하게 할 이유가 없다.
    // 그렇다면 한번 계산해 놓은 값을 계속 쓰면 되잖아? 란 아이디어
    // 라이트매핑 
    // 디렉션 라이트는 , 스포트라이트는 믹스드 세팅
    // window / rendering / lighting 
    // lightin setting 생성 
    // 믹스드 라이팅을 서브트랙티브
    // 오래걸리니까 처음엔 라이트맵 레솔루션은 낮게 해서 굽고 나중에 작업하면서 수정하는게 좋다
    // 라이트맵 사이즈도 높으면 선명하지만 오래걸리니 1024 냅두고
    // 나머진 건들지마
    // 광원의 모드를 Baked로 
    // 글로벌 일루미네이션은 전체적 밝기를 조정하는건데 일단 냅둬보고

    // skybox 는 말그대로 스카이박스
    // 오토 제네레이트 비추천
    // 아무것도 체크 안하고 한번은 구워주는게 좋음 static 설정된 오브젝트가 구워지는것
    // baked 된 광원은 없애도 상관은 없음. 다만 바꿀때 생성하기 귀찮으니까 냅둔다.
    // 베이크 미리 해놓으면 생기는 문제?
    // 플레이어가 나중에 구운 그림자 영향받는 곳에 들어가도 플레이어한테 그림자가 안드리워짐.
    // 즉 베이크는 폴리곤 색을 고정시키는 거라 보면 될듯 기타 이펙트 삭제하고
    // 이 문제 해결해 주는게 라이트 프루브
    // light probe group 생성 / 에디트 라이트 프루브 에디팅 
    // 음영이 맞춰지는 모습을 볼 수 있음

    // 리플렉션 프루브(컴포넌트)
    // 빛 반사관련 동그란 거울 같은걸로 생각?, 베이크하는것
    // 반사 받기 위해선 반사 받는 오브젝트의 재질 바꿔야함.
    // 마테리얼 만들어서 mirror 재질로 만들기. 서페이스 인풋 중 스무스미스 바꿔주면 됨
    // 메탈릭도 높여줄것. 거울에 가까워진다...
    // 이건 리얼타임 비추한다.처리량이 장난아님.
    // 게임 오브젝트로 거울이 필요하면 차라리 카메라로 처리하는게 낫다?
    //질문
    //조명과 이미 bake된 static오브젝트 사이에 플레이어가 지나갈 때, static오브젝트에 그려진 light를 플레이어 그림자로 가리고 싶으면 애초에 리얼타임으로 설정해야 할까요?
    //mixed로 설정 바꿔서 구우면 된다(광원설정을)
    // 라이트 프루브의 갯수가 많다고 부하가 많지는 않다. 적어도 빛계산보단 빠르다.
    // 빛과 그림자가 개발에서 많이 걸림돌이 된다. 그 방법중 하나다
    // 또 다른 방법으로 block shadow 란 기법도. 그림자를 비현실적으로 만들기
    // 데칼? 프로젝터? 이미지 투영? 그림자 연산에서 최적화 어려우면 이걸 쓰자   
    // 베이크된 풍경은 런타임시 변하지 않는것에만 쓰자~

    // 오클루전 컬링
    // 안움직이는 오브젝트 스태틱 눌러주고 
    // 윈도우 / 랜더링 / 오클루전 컬링 에디터에선 퍼포먼스 차이 없음 빌드 뒤에야 효과가 나온다
    // 2d에...되나?
    // 필요한가 싶긴한데 구현 방법은 생각나는게 있긴하다.

    // 카메라를 멀리 줌아웃 하는건 굉장히 부담되는일
    // 멀리서 보는데 폴리건이 그렇게 많을 필요가 없으니 모델링을 단순화 시키는 기능이 있을것이다.
    // LOD ( 레벨 오브 디테일)
    // 적용할 오브젝트에 컴포넌트 LOD Group
    // 랜더러를 단계별로 만들어서 LOD 레벨마다 넣어줘야함

    // 덜그리는게 최적화의 가장 확실한 방법이긴하다
    // 기본적으로 유니티 카메라가 clipping planes 의 far 가 1000으로 되있는데, 이정도는 현실적으로 볼 필요없다.
    // 시야거리니까 조절하면 된다. clipping planes 를 낮춰라
    // 적게 보이니까 좁은곳을 보게되는 느낌은 있긴 함
    // 안개 씌우기도 방법

    // 윈도우/ 랜더링/ 라이팅 / 환경 /포그
    // 멀리있는거 안보이게 하는 기법

    // 다음주에 배울 포스트 프로세싱 / 피사심계도
}
